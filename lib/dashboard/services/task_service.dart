import 'dart:async';
import 'package:mini_taskhub/app/supabase_config.dart';
import 'package:mini_taskhub/dashboard/models/task_model.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

/// Service for managing tasks in the database.
///
/// This service provides methods for creating, reading, updating, and deleting tasks,
/// as well as listening for changes to tasks in real-time.
class TaskService {
  // Singleton pattern to ensure only one instance exists
  static final TaskService _instance = TaskService._internal();

  /// Factory constructor that returns the singleton instance
  factory TaskService() => _instance;

  /// Private constructor for singleton pattern
  TaskService._internal();

  /// Supabase client for database operations
  final _supabase = SupabaseConfig.client;

  /// Stream controller for broadcasting task state changes
  final _taskStateController = StreamController<List<Task>>.broadcast();

  /// Stream of task state changes that UI can listen to
  Stream<List<Task>> get taskStateChanges => _taskStateController.stream;

  /// Name of the tasks table in Supabase
  static const String _tableName = 'tasks';

  /// Retrieves all tasks for a specific user.
  ///
  /// Fetches tasks from the database, orders them by creation date (newest first),
  /// and notifies all listeners about the updated task list.
  ///
  /// [userId] The ID of the user whose tasks to retrieve.
  /// Returns a list of [Task] objects.
  /// Throws an exception if the operation fails.
  Future<List<Task>> getTasks(String userId) async {
    try {
      final response = await _supabase
          .from(_tableName)
          .select()
          .eq('user_id', userId)
          .order('created_at', ascending: false);

      final tasks = response.map((task) => Task.fromSupabase(task)).toList();

      // Notify listeners
      _taskStateController.add(tasks as List<Task>);

      return tasks as List<Task>;
    } catch (e) {
      throw Exception('Failed to get tasks: ${e.toString()}');
    }
  }

  /// Adds a new task to the database.
  ///
  /// Creates a new task record in the database and refreshes the task list.
  /// The task ID is generated by the database.
  ///
  /// [task] The task to add.
  /// Returns the newly created task with its database-assigned ID.
  /// Throws an exception if the operation fails.
  Future<Task> addTask(Task task) async {
    try {
      // Create a map without the ID for insert
      final Map<String, dynamic> taskMap = {
        'user_id': task.userId,
        'title': task.title,
        'description': task.description,
        'is_completed': task.status == TaskStatus.completed,
        'category': task.category,
        'priority': task.priority.index,
        'due_date': task.dueDate?.toIso8601String(),
      };

      final response = await _supabase
          .from(_tableName)
          .insert(taskMap)
          .select()
          .single();

      final newTask = Task.fromSupabase(response);

      // Refresh tasks
      await getTasks(task.userId);

      return newTask;
    } catch (e) {
      throw Exception('Failed to add task: ${e.toString()}');
    }
  }

  /// Updates an existing task in the database.
  ///
  /// Updates the task record in the database and refreshes the task list.
  /// Only the specified fields are updated; the ID and user ID remain unchanged.
  ///
  /// [task] The task with updated values.
  /// Returns the updated task as retrieved from the database.
  /// Throws an exception if the operation fails.
  Future<Task> updateTask(Task task) async {
    try {
      // Create a map without the ID for update
      final Map<String, dynamic> taskMap = {
        'title': task.title,
        'description': task.description,
        'is_completed': task.status == TaskStatus.completed,
        'category': task.category,
        'priority': task.priority.index,
        'due_date': task.dueDate?.toIso8601String(),
      };

      final response = await _supabase
          .from(_tableName)
          .update(taskMap)
          .eq('id', task.id)
          .select()
          .single();

      final updatedTask = Task.fromSupabase(response);

      // Refresh tasks
      await getTasks(task.userId);

      return updatedTask;
    } catch (e) {
      throw Exception('Failed to update task: ${e.toString()}');
    }
  }

  /// Deletes a task from the database.
  ///
  /// Removes the task with the specified ID from the database and refreshes the task list.
  ///
  /// [taskId] The ID of the task to delete.
  /// [userId] The ID of the user who owns the task (needed for refreshing the task list).
  /// Throws an exception if the operation fails.
  Future<void> deleteTask(String taskId, String userId) async {
    try {
      await _supabase
          .from(_tableName)
          .delete()
          .eq('id', taskId);

      // Refresh tasks
      await getTasks(userId);
    } catch (e) {
      throw Exception('Failed to delete task: ${e.toString()}');
    }
  }

  /// Toggles the completion status of a task.
  ///
  /// Fetches the current status of the task, inverts it, and updates the database.
  /// This is a convenience method for quickly marking tasks as completed or pending.
  ///
  /// [taskId] The ID of the task to toggle.
  /// [userId] The ID of the user who owns the task (needed for refreshing the task list).
  /// Returns the updated task with its new status.
  /// Throws an exception if the operation fails.
  Future<Task> toggleTaskStatus(String taskId, String userId) async {
    try {
      // Get current task
      final currentTask = await _supabase
          .from(_tableName)
          .select()
          .eq('id', taskId)
          .single();

      // Toggle status
      final isCompleted = currentTask['is_completed'] == true;

      // Update task
      final response = await _supabase
          .from(_tableName)
          .update({'is_completed': !isCompleted})
          .eq('id', taskId)
          .select()
          .single();

      final updatedTask = Task.fromSupabase(response);

      // Refresh tasks
      await getTasks(userId);

      return updatedTask;
    } catch (e) {
      throw Exception('Failed to toggle task status: ${e.toString()}');
    }
  }

  /// Adds sample tasks for new users.
  ///
  /// This method checks if the user already has tasks, and if not, adds a set of
  /// sample tasks to help them get started with the app. This improves the initial
  /// user experience by providing examples of how to use the app.
  ///
  /// [userId] The ID of the user to add mock tasks for.
  /// Throws an exception if the operation fails.
  Future<void> addMockTasks(String userId) async {
    try {
      // Check if user already has tasks
      final existingTasks = await _supabase
          .from(_tableName)
          .select('id')
          .eq('user_id', userId);

      if (existingTasks.isNotEmpty) {
        // User already has tasks, no need to add mock tasks
        return;
      }

      // Add mock tasks
      final mockTasks = [
        Task(
          userId: userId,
          title: 'Complete Flutter project',
          description: 'Finish the Mini TaskHub app',
          status: TaskStatus.pending,
          category: TaskCategory.work,
          priority: TaskPriority.high,
          dueDate: DateTime.now().add(const Duration(days: 2)),
        ),
        Task(
          userId: userId,
          title: 'Learn Supabase',
          description: 'Study Supabase authentication and database',
          status: TaskStatus.pending,
          category: TaskCategory.education,
          priority: TaskPriority.medium,
          dueDate: DateTime.now().add(const Duration(days: 5)),
        ),
        Task(
          userId: userId,
          title: 'Buy groceries',
          description: 'Milk, eggs, bread, and fruits',
          status: TaskStatus.completed,
          category: TaskCategory.shopping,
          priority: TaskPriority.low,
          dueDate: DateTime.now().subtract(const Duration(days: 1)),
        ),
        Task(
          userId: userId,
          title: 'Go for a run',
          description: '5km morning run',
          status: TaskStatus.pending,
          category: TaskCategory.health,
          priority: TaskPriority.medium,
          dueDate: DateTime.now(),
        ),
        Task(
          userId: userId,
          title: 'Read a book',
          description: 'Flutter development book',
          status: TaskStatus.completed,
          category: TaskCategory.personal,
          priority: TaskPriority.low,
          dueDate: DateTime.now().subtract(const Duration(days: 3)),
        ),
      ];

      for (final task in mockTasks) {
        await addTask(task);
      }
    } catch (e) {
      throw Exception('Failed to add mock tasks: ${e.toString()}');
    }
  }

  /// Cleans up resources used by this service.
  ///
  /// This method should be called when the service is no longer needed
  /// to prevent memory leaks. It closes the stream controller.
  void dispose() {
    _taskStateController.close();
  }
}
